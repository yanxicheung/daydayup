# 软件设计

软件设计是应对需求的“算法”，软件设计要关注长期变化，需要应对需求规模的膨胀

软件的开发目的：软件开发是为了解决由需求带来的各种问题，而解决的结果是一个可以运行的交付物。

比如，我们在线购物的需求，是通过电商平台这个方案解决的。软件设计在这个过程中做的事情是什么呢？在需求和解决方案之间架设一个桥梁。



软件设计，应该包括模型和规范。

模型，是一个软件的骨架，是一个软件之所以是这个软件的核心。（一个电商平台，它不用关系型数据库，还可以用 NoSQL，但如果没有产品信息，没有订单，它就不再是电商平台了。）一个软件之所以为一个软件，是由其模型决定；同样的一个模块之所以为一个模块，也是由其模型决定。模型决定软件解决了什么问题。



规范，就是限定了什么样的需求应该以怎样的方式去完成。规范要符合软件设计原则。



有了模型，有了规范，那模型与规范是什么关系呢？模型与规范，二者相辅相成。

一个项目最初建立起的模型，往往是要符合一定规范的，而规范的制定也有赖于模型。这就像讨论户型设计时，你可以按照各种方式组合不同的空间（模型），却不会把厨房与卫生间放在一起（规范）。



# 分离关注点

把业务处理和技术实现两个关注点混在了一起，随之而来的就是无尽的后患。



在真实项目中，程序员最常犯的错误就是认为所有问题都是技术问题，总是试图用技术解决所有问题。任何试图用技术去解决其他关注点的问题，只能是陷入焦油坑之中，越挣扎，陷得越深。



另外一个常见的容易产生混淆的关注点是不同的数据变动方向，比如：

> 动静分离，就是把变和不变的内容分开；
>
> 读写分离，就是把读和写分开；
>
> 前面提到的高频和低频，也可以分解开；



不同的数据变动方向，就是一个潜在的、可以分离的关注点。



大多数系统的设计做得不够好，问题常常出现在分解这步就没做好。常见的分解问题就是分解的粒度太大，把各种维度混淆在一起。在设计中，将一个模块的不同维度分开，有一个专门的说法，叫分离关注点。



分离关注点很重要，一方面，不同的关注点混在一起会带来许多问题；另一方面，分离关注点有助于我们发现不同模块的共性，更好地进行设计。分离关注点，是我们在做设计的时候，需要时时绷起的一根弦。



今天，我还给你举了两种常见的关注点混淆的情况。一种是技术和业务的混淆，另一种是不同数据变动方向的混淆。希望你在日常开发中，引以为戒。

# 可测试性

在通常的架构中，服务会调用数据库访问的代码。如果是不考虑测试的做法，代码可能写成这样：

```java

class ProductService {
  // 访问数据库的对象
  private ProduceRepository repository = new ProductRepository();
  
  public Product find(final long id) {
    return this.repository.find(id);
  }
}
```

在这里，我们要直接创建数据库访问的对象，然而，要创建数据库访问对象，就要同时把数据库连接起来，你要准备一大堆相关的东西，所以，测试的复杂度就会非常大。

可是，测试这个服务目的是，关心这个服务的逻辑是不是写正确了，这与是不是用数据库没关系啊！所以，如果我考虑了可测试性，**服务的依赖就变成了一个数据访问的接口**：

```java

class ProductService {
  // 访问数据库的对象
  private ProduceRepository repository;
  
  public ProductService(final ProduceRepository repository) {
    this.repository = repository;
  }
  
  public Product find(final long id) {
    return this.repository.find(id);
  }
}
```



当private方法复杂并包含逻辑，其正确应当重构代码，而不是在测试做妥协，可以将需要测试的private方法转移到另一个对象中，成为一个public的方法。



# 模型、接口和实现

了解一个软件设计，可以从三个部分入手：模型、接口和实现。

> 模型，也可以称为抽象，是一个软件的核心部分，是这个系统与其它系统有所区别的关键，是我们理解整个软件设计最核心的部分。
>
> 接口，是通过怎样的方式将模型提供的能力暴露出去，是我们与这个软件交互的入口。
>
> 实现，就是软件提供的模型和接口在内部是如何实现的，是软件能力得以发挥的根基。
>
> 

这三者的关系就好比你去看代码，你会先去看有哪些类以及它们之间的关系，这就是看模型；然后你会打开一个具体的类，看它提供了哪些方法，这就相当于看接口；最后，你再来打开一个具体的方法，去看它的代码是怎么写的，这就是看实现。



在一个系统的设计中，模型是最核心的部分。如果模型变了，这个软件便不再是这个软件了，而接口通常反映的就是模型。所以，模型和接口的稳定度都要比实现高，实现则是要随着软件发展而不断调整。

## 实例Kafka：













































































































































































![img](https://static001.geekbang.org/resource/image/c3/37/c33374c66f20f52ce6119e64b53ae137.jpg?wh=2248*729)





![img](https://static001.geekbang.org/resource/image/50/a2/50983d3d104c811f33f02db1783d4da2.jpg?wh=2323*652)

理解软件设计中模型首先要理解模型解决的核心问题是什么，然后抽丝剥茧了解模型的来龙去脉，深入理解模型解决问题的过程。

 spring中的DI（ Dependency Injection）模型是为了解决对象的创建和组装的问题。

 那为什么创建对象和组装要用di来解决？ 一个重要的原因是为了解耦。

分离接口与实现的强依赖，也就是软件设计第一步分离关注点。

 而这个恰恰就是为了可测试性，当一个代码是可测的，其实就是说明它是比较灵活的，修改起来不会牵一发而动全身，提高开发的体验，减少因修改引入的额外问题